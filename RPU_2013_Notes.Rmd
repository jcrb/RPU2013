Notes techniques
========================================================
Table des matières
------------------
1. notes techniques
2. cartographie
3. population





Notes techniques
================

gdata est utile pour la méthode drop.levels() qui supprime les levels inutiles:
(ref: http://rwiki.sciviews.org/doku.phpéid=tips:data-manip:drop_unused_levels)

note: pour supprimer les messages inutiles *{r message=FALSE}*

note: pour supprimer les warnings: *{r warning=FALSE}*

# A NE FAIRE QU'UNE FOIS AU DEBUT DE LA SESSION:
# loadhistory(file = ".Rhistory")
# timestamp()
# A FAIRE SI ON CHANGE DE WORKING DIRECTORY
# sauvegarde: savehistory(file = ".Rhistory")

Pour que les légendes de l'axe des Y soient perpendiculaires a ce dernier, rajouter *las = 1*
Pour que les légendes de l'axe des X soient perpendiculaires a ce dernier, rajouter *las = 2*
Pour que les légendes soient perpendiculaires aux 2 axes, rajouter *las = 3*
Par défaut *las = 0*

L'utilisation de la méthode *SweaveInput* provoque un erreur si le fichier à inclure comporte des caractéres accenués (méme enregistrés en UTF8)

Création d'un tableau avec *cbind* et une matrice (et xtable pour pdf): voir exhaustivité des données

Version:
```{r version}
sessionInfo()
toLatex(sessionInfo())
```
Pour présenter en latex un tableau type *summary*:
stargazer(as.data.frame(a2[1:length(a)]),summary=TRUE,digit.separator=" ",digits=2,median=TRUE,iqr=TRUE)

Outils de présentation
======================
Sont également utilisables pour le site internet de Resural:
- Interactive presentation with slidify and googleVis: comment faire un diaporama en R en incorporant des graphiques interactifs présentés via googlevis et les incorporer dans son site http://feedproxy.google.com/~r/RBloggers/~3/4w4oN8fMOa4/?utm_source=feedburner&utm_medium=email

Notes de cartographie
=====================

références utiles
-----------------
- dossier stat Resural/carto&pop.rmd
  - carto67.rda
  - carto68.rda
  - carto_alsace.rda
- http://help.nceas.ucsb.edu/r:spatial comment utiliser les ressources de R


Notes sur les populations
=========================
- utilisation du recensement 2010
- dossier stat Resural/carto&pop.rmd
  - pop67.rda
  - pop68.rda
- source INSEE
  - http://www.insee.fr/fr/ppp/bases-de-donnees/recensement/populations-legales/france-regions.asp?annee=2010
   - http://www.insee.fr/fr/ppp/bases-de-donnees/recensement/populations-legales/france
-departements.asp?annee=2010 (fichier excel)
  - http://www.insee.fr/fr/ppp/bases-de-donnees/recensement/populations-legales/departement.asp?dep=67&annee=2010
  - http://www.insee.fr/fr/ppp/bases-de-donnees/recensement/populations-legales/departement.asp?dep=68&annee=2010
  - Liste des cantons, communes, arrondissements, pays: http://www.insee.fr/fr/methodes/nomenclatures/cog/telechargement.asp
  
- population légale 2010: 
  - Alsace   1 845 687

N°  |  Département  |  nb.communes  |  Pop.municipale  |  Pop.totale
----|---------------|---------------|------------------|-------------
67 |  Bas-Rhin |	527 |  1 095 905 | 1 115 226 
68 |	Haut-Rhin | 377  | 749 782 | 765 634 


Fichier ville de la base *pma*
------------------------------
Fichier exporté de la base *pma* sous le nom de *ville.csv* (5/6/2013)

```{r}
file<-"ville.csv"
v<-read.csv(file, header=TRUE, sep=",")
names(v)
```
On ne retient que les villes d'Alsace:
```{r}
va<-v[v$region_ID=="42",]
```
mise en forme:
```{r}
va$zone_proximite<-as.factor(va$zone_proximite)
va$territoire_sante<-as.factor(va$territoire_sante)
```
villes où la ZP est manquante:
```{r}
a<-va[va$zone_proximite==0,c(1:3)]
a
```

Résultats:
```{r}
summary(va$zone_proximite)
```
Combinaisons des fichiers
-------------------------
On forme un fichier commun avec
- pop67
- pop68
- va
de façon a avoir dans une même base les zones de proximité (va) et les populations correspondantes:
```{r}
load("~/Documents/Resural/Stat Resural/carto&pop/pop68.rda")
load("~/Documents/Resural/Stat Resural/carto&pop/pop67.rda")
base1<-merge(va,pop67,by.x="ville_insee",by.y="insee")
base2<-merge(va,pop68,by.x="ville_insee",by.y="insee")
base<-rbind(base1,base2)
names(base)
rm(base1,base2)
```
Note: le résultat pourrait être simplifié car des colonnes sont redondantes;

Communes où la zone de proximité est manquante:
```{r}
a<-base[base$zone_proximite==0,c(1,3)]
a
```
corrections:
```{r}
base$zone_proximite[53]<-3
base$territoire_sante[53]<-1

base$zone_proximite[572]<-1
base$territoire_sante[572]<-4

base$zone_proximite[57]<-3
```


population de la région:
```{r}
n<-sum(base$Population.totale)
n
```
Population par zone de proximité:
```{r}
effectif<-tapply(base$Population.totale,as.factor(base$zone_proximite),sum,na.rm=TRUE)
effectif
pourcentage<-round(prop.table(effectif)*100,2)
pourcentage
c<-cbind(effectif,pourcentage)
c
barplot(sort(effectif),cex.names=0.8,xlab="Territoire de proximité",ylab="% de la population totale",main="Répartition de la population par territoire de santé")
```
Créer une zone de proximité
---------------------------
On fait la liste de tous les codes INSEE de la zone de proximité1:
```{r}
zip1<-base$ville_insee[base$zone_proximite==1]
head(zip1)
```
Puis on fait la liste des villes correspondant à ces codes:
```
b<-paste(zip1,sep=",")
a<-base$ville_nom[base$ville_insee %in% b]
a[1:5]
```
essai de carto associée:
------------------------
La méthode dessine tous les polygones présents qui répondent à un critère de sélection. On utilise le fichier *carto_alsace.rda* qui produit un objet *SpatialPolygonsDataFrame* appelé *als*.
```{r als}
library("maptools")
load("/home/jcb/Documents/Resural/Stat Resural/carto&pop/carto_alsace.rda")
names(als)
contour<-unionSpatialPolygons(als,IDs=als@data$CODE_ARR)
plot(contour)
```
Contour de la zone de proximié n°1 (code INSEE stockés dans b) dans la région Alsace
```{r contour}
library("maptools")
b<-paste(zip1,sep=",")
a<-base$ville_nom[base$ville_insee %in% b]
contour<-unionSpatialPolygons(als,IDs=als@data$INSEE_COM %in% b)
plot(contour)
```
Contour de la zone de proximié n°1 (seule)

```{r zp1}

b<-paste(zip1,sep=",")
a<-base$ville_nom[base$ville_insee %in% b]
zp1<-als[als@data$INSEE_COM %in% b,]
plot(zp1)
```
*zp1* est également un *SpatialPolygonsDataFrame* qui contient les mêmes éléments que l'élément racine:
```{r}
names(zp1)
```
On peut donc lui appliquer les mêmes fonctions. Par exemple on peut tracer une figure qui représente les contours de la zone de proximité:
```{r}
contour<-unionSpatialPolygons(zp1,IDs=zp1@data$CODE_ARR)
plot(contour,axes=T)
```
*contour* est un *SpatialPolygons*.

Il est possible de superposer les 2 graphiques en ajoutant add=TRUE:
```{r}
plot(contour,axes=T,xlab="axe x",col="red")
plot(zp1, add=T)
```
modifier l'aspect:
- lty = 1 (normal), 2, 3, 4, 5... (pointillés)
- lwd = 1 épaisseur du trait
- fg = "red" couleur des axes
- bg = "blue" couleur de fond de l'image
- col = "green" couleur de fond du polygone. col=NA or col="transparent" pour un fond transparent.
- border = "red" couleur de la bordure

exemple:
```{r}
plot(zp1,,axes=T)
plot(contour,axes=T,lty=1,lwd=2,fg="blue",border="red",add=T)
```
Certains caractères accentués posent des pb comme dans *préfecture*:
```{r}
summary(zp1$STATUT)
```
Avec la fonction *gsub*, on remplace les caractères anormaux par *e*:
```{r}
zp1$STATUT<-gsub("\xe9","e",zp1$STATUT,fixed=F)
summary(as.factor(zp1$STATUT))
```
Il est alorspossible de récupérer les coordonées de la sous-préfecture. Il faut d'abord récupérer le dataframe associé à zp1. NB il faut multiplier les coordonnées x et y par 100 pour être cohérent avec la carte. pch = 19 désigne le symbole rond plein.
```{r}
a<-zp1@data
head(a)

sp<-a[a$STATUT == "Sous-prefecture",]
sp

x<-sp$X_CHF_LIEU * 100
y<-sp$Y_CHF_LIEU * 100
nom<-sp$NOM_COMM

plot(contour)
points(x,y,pch=19,col=3)
text(x,y,labels=nom,cex=0.8,pos=3)
```
Les zones de proximités officielles sont dans le fichier zp.csv
```{r}
zpo<-read.csv("zp.csv",header=TRUE, sep=",")
names(zpo)
print("Nb de communes par territoire de santé")
a<-zpo$LIBELLE.DES.TERRITOIRES.DE.SANTE
summary(a)
print("Nb de communes par territoire de proximité")
a<-zpo$LIBELLE.DES.ZONES.DE.PROXIMITE
summary(a)
```
NB: la numérotation ARS des territoires de proximité de proximité ne correspond pas à celle de Sagec. Le code commune du fichier zpo correspond au code INSEE.

Utilisation du fichier *zpo* à la place du fichier *ville*
-----------------------------------------------------------
Crée un objet *zone de proximité 2*, en dessine le contour ainsi que le chef lieu:

```{r}
zpo<-read.csv("zp.csv",header=TRUE, sep=",")
base1<-merge(zpo,pop67,by.x="CODE.COMMUNE",by.y="insee")
base2<-merge(zpo,pop68,by.x="CODE.COMMUNE",by.y="insee")
base<-rbind(base1,base2)
rm(base1,base2)
names(base)

# spécifique de la zone de proximité 2
zip2<-base$CODE.COMMUNE[base$CODE.ZONES.DE.PROXIMITE==2]
b<-paste(zip2,sep=",")
zp2<-als[als@data$INSEE_COM %in% b,]
plot(zp2)

contour2<-unionSpatialPolygons(zp2,IDs=zp2@data$CODE_DEPT)
plot(contour2)

zp2$STATUT<-gsub("\xe9","e",zp2$STATUT,fixed=F)
a<-zp2@data
sp<-a[a$STATUT == "Sous-prefecture",]
x<-sp$X_CHF_LIEU * 100
y<-sp$Y_CHF_LIEU * 100
nom<-sp$NOM_COMM
points(x,y,pch=19,col=3)
text(x,y,labels=nom,cex=0.8,pos=3)
```
Zone de proximité 3

```{r}
zip3<-base$CODE.COMMUNE[base$CODE.ZONES.DE.PROXIMITE==3]
b<-paste(zip3,sep=",")
zp3<-als[als@data$INSEE_COM %in% b,]
plot(zp3)

contour3<-unionSpatialPolygons(zp3,IDs=zp3@data$CODE_DEPT)
plot(contour3)

zp3$STATUT<-gsub("\xe9","e",zp2$STATUT,fixed=F)
a<-zp3@data
sp<-a[a$STATUT == "Sous-prefecture",]
x<-sp$X_CHF_LIEU * 100
y<-sp$Y_CHF_LIEU * 100
nom<-sp$NOM_COMM
points(x,y,pch=19,col=3)
text(x,y,labels=nom,cex=0.8,pos=3)
plot(contour2,add=T)
```






